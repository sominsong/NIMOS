#define _GNU_SOURCE
#include <err.h>
#include <unistd.h>
#include <fcntl.h>
#include <termios.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/wait.h>

int main(void) {
  sync(); /* we're probably gonna crash... */

  /*
   * We may already be process group leader but want to be session leader;
   * therefore, do everything in a child process.
   */
  pid_t main_task = fork();
  if (main_task == -1) return -1;
  if (main_task != 0) {
    int status;
    if (waitpid(main_task, &status, 0) != main_task)
      return -1;
    return 0;
  }
  if (prctl(PR_SET_PDEATHSIG, SIGKILL))
    return -1;
  if (getppid() == 1) exit(0);

  /* basic preparation */
  if (signal(SIGTTOU, SIG_IGN))
    return -1;
  if (setsid() == -1)
    return -1;

  /* set up a new pty pair */
  int ptmx = open("/dev/ptmx", O_RDWR);
  if (ptmx == -1)
    return -1;
  unlockpt(ptmx);
  int tty = open(ptsname(ptmx), O_RDWR);
  if (tty == -1)
    return -1;

  /*
   * Let a series of children change the ->pgrp pointer
   * protected by the tty's ctrl_lock...
   */
  pid_t child = fork();
  if (child == -1)
    return -1;
  if (child == 0) {
    if (prctl(PR_SET_PDEATHSIG, SIGKILL))
      return -1;
    if (getppid() == 1) exit(0);

    while (1) {
      pid_t grandchild = fork();
      if (grandchild == -1)
        return -1;
      if (grandchild == 0) {
        if (setpgid(0, 0))
          return -1;
        int pgrp = getpid();
        if (ioctl(tty, TIOCSPGRP, &pgrp))
          return -1;
        exit(0);
      }
      int status;
      if (waitpid(grandchild, &status, 0) != grandchild)
        return -1;
    }
  }

  /*
   * ... while the parent changes the same ->pgrp pointer under the
   * ctrl_lock of the other side of the pty pair.
   */
  while (1) {
    int pgrp = getpid();
    if (ioctl(ptmx, TIOCSPGRP, &pgrp))
      return -1;
  }
}